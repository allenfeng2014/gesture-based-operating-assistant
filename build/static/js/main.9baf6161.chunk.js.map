{"version":3,"sources":["App.js","Background.js","index.js"],"names":["chrome","storage","sync","set","appActive","console","log","App","webcamRef","useRef","intervalID","handDetector","handDetected","estimator","FingerPoseEstimator","detectHandpose","operation","a","current","video","readyState","estimateHands","hand","length","estimate","landmarks","gestureSamples","push","sampleCount","document","getElementById","innerText","startDetector","setInterval","stopDetector","clearInterval","startTraining","e","target","id","split","stopTraining","generateDescription","innerHTML","gestures","gestureDescriptions","gestureNicknames","finger","description","curls","values","weights","directions","prop","propSamples","counts","i","Set","forEach","val","indexOf","maxCount","Math","max","count","index","saveGesture","get","result","filter","deleteGesture","saveNickname","value","styles","operationBlock","display","fontSize","button","margin","interfaceTitle","fontWeight","marginTop","handpose","loadHandposeModel","className","ref","style","position","top","left","right","textAlign","width","height","onClick","map","marginLeft","backgroundColor","minWidth","type","querySelector","gestureEstimator","descriptions","onChanged","addListener","changes","Object","keys","includes","gesture","fp","fingers","fingerCurls","fingerDirects","curl","j","addCurl","dir","addDirection","navigator","mediaDevices","getUserMedia","audio","facingMode","ideal","then","stream","srcObject","catch","err","startGestureOA","alert","getTracks","track","stop","scripts","scrollUp","code","scrollDown","togglePointer","join","pointerUp","pointerDown","pointerLeft","pointerRight","pointerClick","goBackPage","goForwardPage","pointerVisible","prevTabID","JSON","stringify","gestureEstimated","windows","getLastFocused","populate","window","tabs","tab","active","executeScript","name","ReactDOM","render"],"mappings":"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","file":"static/js/main.9baf6161.chunk.js","sourcesContent":["/*global chrome*/\nimport React, { useRef, useState, useEffect } from \"react\";\nimport Webcam from \"react-webcam\";\nimport * as handpose from \"@tensorflow-models/handpose\";\nimport * as tf from \"@tensorflow/tfjs\";\nimport FingerPoseEstimator from \"fingerpose/src/FingerPoseEstimator\";\nimport * as fp from \"fingerpose\";\n\nchrome.storage.sync.set({ appActive: false }, () => {\n  console.log(\"active set to false\");\n});\n\nfunction App() {\n  const webcamRef = useRef(null);\n  let intervalID = null;\n  let handDetector = {};\n  let handDetected = {};\n  const estimator = new FingerPoseEstimator({});\n\n  const detectHandpose = async (handDetector, operation) => {\n    if (\n      typeof webcamRef.current !== \"undefined\" &&\n      webcamRef.current !== null &&\n      webcamRef.current.video.readyState === 4\n    ) {\n      const video = webcamRef.current.video;\n      const hand = await handDetector.estimateHands(video);\n      if (hand.length > 0) {\n        handDetected = estimator.estimate(hand[0].landmarks);\n        console.log(handDetected);\n        if (operation !== \"test\") {\n          gestureSamples[operation].push(handDetected);\n          sampleCount += 1;\n          document.getElementById(\n            `sampleCount-${operation}`\n          ).innerText = `Samples Captured: ${sampleCount}`;\n        }\n        //const gestureEstimated = await gestureEstimator.estimate(\n        //  hand[0].landmarks,\n        //  8\n        //);\n        //console.log(gestureEstimated.gestures[0]);\n      } else {\n        console.log(\"hand not detected\");\n      }\n    }\n  };\n\n  const startDetector = async (operation) => {\n    if (!intervalID) {\n      intervalID = setInterval(\n        () => detectHandpose(handDetector, operation),\n        500\n      );\n      console.log(\"detector started\");\n    } else {\n      console.log(\"detector already in progress\");\n    }\n  };\n\n  const stopDetector = async () => {\n    if (intervalID) {\n      clearInterval(intervalID);\n      console.log(\"detector stopped\");\n      intervalID = null;\n    } else {\n      console.log(\"no detector in progress\");\n    }\n  };\n\n  let gestureSamples = {};\n  let sampleCount = 0;\n  const startTraining = async (e) => {\n    let operation = e.target.id.split(\"-\")[1];\n    sampleCount = 0;\n    gestureSamples[operation] = [];\n    startDetector(operation);\n  };\n  const stopTraining = async (e) => {\n    let operation = e.target.id.split(\"-\")[1];\n    stopDetector();\n    console.log(gestureSamples[operation]);\n    generateDescription(operation);\n    document.getElementById(`trainStatus-${operation}`).innerHTML =\n      \"data captured, save if you want\";\n  };\n\n  let gestures = [];\n  let gestureDescriptions = {};\n  let gestureNicknames = {};\n\n  const generateDescription = (operation) => {\n    gestureDescriptions[operation] = [];\n    for (let finger of [0, 1, 2, 3, 4]) {\n      let description = {\n        curls: {\n          values: [],\n          weights: [],\n        },\n        directions: {\n          values: [],\n          weights: [],\n        },\n      };\n      for (let prop of [\"curls\", \"directions\"]) {\n        let propSamples = [];\n        let counts = [];\n        let weights = [];\n        for (let i = 0; i < gestureSamples[operation].length; i++) {\n          propSamples.push(gestureSamples[operation][i][prop][finger]);\n        }\n        let values = [...new Set(propSamples)];\n        values.forEach(() => {\n          counts.push(0);\n          weights.push(0);\n        });\n        propSamples.forEach((val) => {\n          counts[values.indexOf(val)] += 1;\n        });\n        let maxCount = Math.max(...counts);\n        counts.forEach((count, index) => {\n          weights[index] = count / maxCount;\n          if (count / maxCount === 0) {\n            console.log(\"!!!!!!!!!!!!!!!!!!weight 0\", values, counts);\n          }\n        });\n        description[prop] = { values, weights };\n      }\n      gestureDescriptions[operation].push(description);\n    }\n    console.log(gestureDescriptions[operation]);\n  };\n\n  const operations = [\n    \"scrollUp\",\n    \"scrollDown\",\n    \"togglePointer\",\n    \"pointerLeft\",\n    \"pointerRight\",\n    \"pointerUp\",\n    \"pointerDown\",\n    \"pointerClick\",\n    \"goBackPage\",\n    \"goForwardPage\",\n  ];\n\n  const saveGesture = (e) => {\n    let operation = e.target.id.split(\"-\")[1];\n    chrome.storage.sync.get([\"gestures\"], (result) => {\n      if (result.gestures.length > 0) {\n        gestures = result.gestures.filter((description) => {\n          return description.operation !== operation;\n        });\n      }\n      gestures.push({\n        operation,\n        gestureDescriptions: gestureDescriptions[operation],\n      });\n      document.getElementById(`trainStatus-${operation}`).innerText = \"trained\";\n      console.log(\"new gestures\", gestures);\n      chrome.storage.sync.set({ gestures });\n    });\n  };\n\n  const deleteGesture = (e) => {\n    let operation = e.target.id.split(\"-\")[1];\n    chrome.storage.sync.get([\"gestures\"], (result) => {\n      if (result.gestures.length > 0) {\n        gestures = result.gestures.filter((description) => {\n          return description.operation !== operation;\n        });\n      }\n      document.getElementById(`trainStatus-${operation}`).innerText =\n        \"untrained\";\n      console.log(\"new gestures\", gestures);\n      chrome.storage.sync.set({ gestures });\n    });\n  };\n\n  const saveNickname = (e) => {\n    let operation = e.target.id.split(\"-\")[1];\n    chrome.storage.sync.get([\"gestureNicknames\"], (result) => {\n      if (result.gestureNicknames) {\n        gestureNicknames = result.gestureNicknames;\n      } else {\n        gestureNicknames = {};\n      }\n      gestureNicknames[operation] = document.getElementById(\n        `nicknameInput-${operation}`\n      ).value;\n      chrome.storage.sync.set({ gestureNicknames });\n    });\n  };\n\n  const loadHandposeModel = async () => {\n    handDetector = await handpose.load();\n    console.log(\"handpose model loaded\");\n  };\n\n  const styles = {\n    operationBlock: {\n      display: \"block\",\n      fontSize: 14,\n    },\n    button: {\n      margin: \"0px 5px\",\n    },\n    interfaceTitle: {\n      fontSize: 18,\n      fontWeight: \"bold\",\n      marginTop: \"5px\",\n    },\n  };\n\n  loadHandposeModel();\n\n  return (\n    <div className=\"App\">\n      <div className=\"webcam-container\">\n        <Webcam\n          ref={webcamRef}\n          style={{\n            position: \"fixed\",\n            margin: \"auto\",\n            top: \"20px\",\n            left: \"50%\",\n            right: 0,\n            textAlign: \"center\",\n            width: 560,\n            height: 400,\n          }}\n        />\n      </div>\n      <div id=\"detector-test\">\n        <button onClick={() => startDetector(\"test\")}>Start Detector</button>\n        <button onClick={stopDetector}>Stop Detector</button>\n      </div>\n      {operations.map((operation) => (\n        <div id={`interface-${operation}`}>\n          <div style={styles.interfaceTitle}>\n            <span style={{ display: \"inline-block\", width: \"140px\" }}>\n              {operation}:\n            </span>\n            <span\n              id={`trainStatus-${operation}`}\n              style={{\n                fontWeight: \"normal\",\n                marginLeft: \"5px\",\n                backgroundColor: \"#DAE1E6\",\n              }}\n            >\n              untrained\n            </span>\n            <span\n              id={`nickname-${operation}`}\n              style={{ marginLeft: \"10px\" }}\n            ></span>\n          </div>\n          <div style={styles.operationBlock}>\n            <span id={`sampleCount-${operation}`} style={{ minWidth: \"135px\" }}>\n              Samples Captured: {sampleCount}\n            </span>\n            <button\n              id={`trainStart-${operation}`}\n              style={styles.button}\n              onClick={startTraining}\n            >\n              Start Training\n            </button>\n            <button\n              id={`trainStop-${operation}`}\n              style={styles.button}\n              onClick={stopTraining}\n            >\n              Stop Training\n            </button>\n            <button\n              id={`saveGesture-${operation}`}\n              style={styles.button}\n              onClick={saveGesture}\n            >\n              Save Gesture\n            </button>\n            <button\n              id={`deleteGesture-${operation}`}\n              style={styles.button}\n              onClick={deleteGesture}\n            >\n              Delete Gesture\n            </button>\n            <input\n              type=\"text\"\n              id={`nicknameInput-${operation}`}\n              style={{ width: \"100px\" }}\n            ></input>\n            <button\n              id={`saveNickname-${operation}`}\n              style={styles.button}\n              onClick={saveNickname}\n            >\n              Save Nickname\n            </button>\n          </div>\n        </div>\n      ))}\n      <button\n        onClick={() => {\n          chrome.storage.sync.set({ gestures: {} });\n        }}\n      >\n        !!! Delete Model !!!\n      </button>\n    </div>\n  );\n}\n\nexport default App;\n","/* global chrome*/\r\nimport * as handpose from \"@tensorflow-models/handpose\";\r\nimport * as tf from \"@tensorflow/tfjs\";\r\nimport FingerPoseEstimator from \"fingerpose/src/FingerPoseEstimator\";\r\nimport * as fp from \"fingerpose\";\r\n\r\nconst video = document.querySelector(\"#backgroundVideo\");\r\n// turn off app at start up\r\nchrome.storage.sync.set({ appActive: false });\r\n\r\n// gesture object trained by user\r\nlet gestures = [];\r\nlet gestureEstimator = null;\r\nlet descriptions = [];\r\n\r\nchrome.storage.onChanged.addListener((changes) => {\r\n  if (Object.keys(changes).includes(\"appActive\")) {\r\n    chrome.storage.sync.get([\"appActive\"], (result) => {\r\n      console.log(\"changed value\", result.appActive);\r\n      if (!result.appActive) {\r\n        // stop gesture OA, stop video steam\r\n        clearInterval(intervalID);\r\n        if (video.srcObject) {\r\n          let mediaTracks = video.srcObject.getTracks();\r\n          mediaTracks.forEach((track) => track.stop());\r\n          alert(\"Gesture-Based OA stopped.\");\r\n        }\r\n      } else {\r\n        // start gesture OA\r\n        chrome.storage.sync.get([\"gestures\"], (result) => {\r\n          descriptions = result.gestures;\r\n          console.log(\"loaded gesture descriptions: \", descriptions);\r\n          gestures = [];\r\n\r\n          descriptions.forEach((description) => {\r\n            let { operation, gestureDescriptions } = description;\r\n            let gesture = new fp.GestureDescription(operation);\r\n\r\n            const fingers = [\"Thumb\", \"Index\", \"Middle\", \"Ring\", \"Pinky\"];\r\n            const fingerCurls = [\"NoCurl\", \"HalfCurl\", \"FullCurl\"];\r\n            const fingerDirects = [\r\n              \"VerticalUp\",\r\n              \"VerticalDown\",\r\n              \"HorizontalLeft\",\r\n              \"HorizontalRight\",\r\n              \"DiagonalUpRight\",\r\n              \"DiagonalUpLeft\",\r\n              \"DiagonalDownRight\",\r\n              \"DiagonalDownLeft\",\r\n            ];\r\n            gestureDescriptions.forEach((description, i) => {\r\n              description.curls.values.forEach((curl, j) => {\r\n                gesture.addCurl(\r\n                  fp.Finger[fingers[i]],\r\n                  fp.FingerCurl[fingerCurls[curl]],\r\n                  description.curls.weights[j]\r\n                );\r\n              });\r\n              description.directions.values.forEach((dir, j) => {\r\n                gesture.addDirection(\r\n                  fp.Finger[fingers[i]],\r\n                  fp.FingerDirection[fingerDirects[dir]],\r\n                  description.directions.weights[j]\r\n                );\r\n              });\r\n            });\r\n            gestures.push(gesture);\r\n          });\r\n          gestureEstimator = new fp.GestureEstimator(gestures);\r\n\r\n          loadMediaStream(video);\r\n          startGestureOA();\r\n          alert(\"Gesture-Based OA started.\\nPlease refresh current page.\");\r\n        });\r\n      }\r\n    });\r\n  }\r\n});\r\n\r\nfunction loadMediaStream(video) {\r\n  if (navigator.mediaDevices.getUserMedia) {\r\n    navigator.mediaDevices\r\n      .getUserMedia({\r\n        audio: false,\r\n        video: {\r\n          facingMode: \"user\",\r\n          width: { ideal: 560 },\r\n          height: { ideal: 400 },\r\n        },\r\n      })\r\n      .then((stream) => {\r\n        video.srcObject = stream;\r\n      })\r\n      .catch((err) => {\r\n        console.log(err);\r\n      });\r\n  }\r\n}\r\n\r\nlet intervalID = null;\r\nconst startGestureOA = async () => {\r\n  const handDetector = await handpose.load();\r\n  console.log(\"handpose handDetector loaded\");\r\n  intervalID = setInterval(\r\n    () => detectHandpose(handDetector, gestureEstimator),\r\n    500\r\n  );\r\n};\r\n\r\nlet handDetected = {};\r\nconst estimator = new FingerPoseEstimator({});\r\n\r\nconst scripts = {\r\n  scrollUp: {\r\n    code: \"window.scrollTo(window.scrollX, window.scrollY-100);\",\r\n  },\r\n  scrollDown: {\r\n    code: \"window.scrollTo(window.scrollX, window.scrollY+100);\",\r\n  },\r\n  togglePointer: {\r\n    code: [\r\n      \"$('#pointer').toggle();\",\r\n      \"$('#pointer').css({left: '50%', top: '50%'});\",\r\n    ].join(\"\"),\r\n  },\r\n  pointerUp: {\r\n    code: [\r\n      \"if ($('#pointer').is(':visible')) {\",\r\n      \"  $('#pointer').animate({top: '-=30'}, 1);\",\r\n      \"}\",\r\n    ].join(\"\"),\r\n  },\r\n  pointerDown: {\r\n    code: [\r\n      \"if ($('#pointer').is(':visible')) {\",\r\n      \"  $('#pointer').animate({top: '+=30'}, 1);\",\r\n      \"}\",\r\n    ].join(\"\"),\r\n  },\r\n  pointerLeft: {\r\n    code: [\r\n      \"if ($('#pointer').is(':visible')) {\",\r\n      \"  $('#pointer').animate({left: '-=30'}, 1);\",\r\n      \"}\",\r\n    ].join(\"\"),\r\n  },\r\n  pointerRight: {\r\n    code: [\r\n      \"if ($('#pointer').is(':visible')) {\",\r\n      \"  $('#pointer').animate({left: '+=30'}, 1);\",\r\n      \"}\",\r\n    ].join(\"\"),\r\n  },\r\n  pointerClick: {\r\n    code: [\r\n      \"if ($('#pointer').is(':visible')) {\",\r\n      \"  let position = $('#pointer').position();\",\r\n      \"  $('#pointer').hide();\",\r\n      \"  document.elementFromPoint(\",\r\n      \"    position.left + 25, position.top + 25\",\r\n      \"    ).click();\",\r\n      \"  $('#pointer').show();\",\r\n      \"}\",\r\n    ].join(\"\"),\r\n  },\r\n  goBackPage: {\r\n    code: \"history.back();\",\r\n  },\r\n  goForwardPage: {\r\n    code: \"history.forward();\",\r\n  },\r\n};\r\n\r\nlet pointerVisible = false;\r\nlet prevTabID = null;\r\nconst detectHandpose = async (handDetector) => {\r\n  const hand = await handDetector.estimateHands(video);\r\n  if (hand.length > 0) {\r\n    handDetected = estimator.estimate(hand[0].landmarks);\r\n    console.log(JSON.stringify(handDetected));\r\n    const gestureEstimated = await gestureEstimator.estimate(\r\n      hand[0].landmarks,\r\n      7.5\r\n    );\r\n\r\n    if (gestureEstimated.gestures.length > 0) {\r\n      chrome.windows.getLastFocused(\r\n        {\r\n          populate: true,\r\n        },\r\n        (window) => {\r\n          for (let tab of window.tabs) {\r\n            if (tab.active) {\r\n              if (tab.id !== prevTabID) {\r\n                pointerVisible = false;\r\n                console.log(\"tab changed\");\r\n                chrome.tabs.executeScript(tab.id, {\r\n                  code: [\r\n                    \"$('#pointer').css({top:'50%', left:'50%'});\",\r\n                    \"$('#pointer').hide();\",\r\n                  ].join(\"\"),\r\n                });\r\n                prevTabID = tab.id;\r\n              }\r\n              let gestures = gestureEstimated.gestures.filter((gesture) => {\r\n                if (pointerVisible) {\r\n                  return gesture.name.includes(\"ointer\");\r\n                } else {\r\n                  return !gesture.name.includes(\"pointer\");\r\n                }\r\n              });\r\n              if (gestures.length > 0) {\r\n                if (gestures[0].name === \"togglePointer\") {\r\n                  pointerVisible = !pointerVisible;\r\n                  console.log(\"pointerVisible: \", pointerVisible);\r\n                }\r\n                chrome.tabs.executeScript(tab.id, scripts[gestures[0].name]);\r\n                console.log(gestures[0].name);\r\n              }\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      );\r\n    }\r\n  } else {\r\n    console.log(\"hand not detected\");\r\n  }\r\n};\r\n\r\nfunction Background() {}\r\n\r\nexport default Background;\r\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport App from \"./App\";\nimport Background from \"./Background\";\n\nReactDOM.render(<App />, document.getElementById(\"root\"));\n"],"sourceRoot":""}